#summary Task #4 for ilab students: stack machine with conditional jumps

= Задание 5. Стековая машина с условными переходами =

Разовьём [http://code.google.com/p/mipt-ilab-course/w/edit/StackMachine задание 4]. Добавим в язык метки и одну команду условного перехода:

 * `:ЧИСЛО` - метка для совершения перехода с номером ЧИСЛО. Пример: `:42`.
 * `jb ЧИСЛО` - снимает пару чисел `a` и `b` со стека. Делает переход на метку `ЧИСЛО`, если
`a < b`. Иначе продолжает выполнение программы со следующей строчки.

Например, вот эта программа печатает 42 в вечном цикле:
<code language="asm">
:1       ; метка с номером 1, не попадёт в ассемблированный файл, не исполняется
push 42  ; кладём на стек число 42
out      ; снимаем число 42 со стека и печатаем его
push 0   ; кладём на стек число 0
push 1   ; кладём на стек число 1
jb 1     ; если 0 < 1, то делаем переход на метку 1 (вечный цикл)</code>

Также стоит добавить либо команду `dup` (продублировать вершину стека), либо две команды работы с регистром:
- `pop_ax` - снести вершину стека в регистр `ax`
- `push_ax` - положить значение регистра `ax` на стек (регистр при этом сохраняет своё значение)

Напишем программу, которая печатает квадраты первых 10 натуральных чисел. Реализация через регистр:
<code language="asm">
push 0   ; начальное значение счётчика цикла
:1       ; метка начала цикла
push 1   ; кладём единицу, на которую увеличим счётчик цикла
add      ; инкремент счётчика
pop_ax   ; кладём счётчик в регистр
push_ax  ; сохраняем счётчик для следующей итерации
push_ax  ; копия для проверки условия выхода из цикла
push_ax  ; дубликат для подсчёта квадрата
push_ax  ; дубликат для подсчёта квадрата
push_ax  ; дубликат для вывода числа
out      ; выводим само число
mul      ; считаем квадрат числа
out      ; выводим квадрат числа
push 10  ; кладём граничное значение цикла
jb :1    ; прыжок если stack[-2] < stack[-1]</code>

Реализация через `dup`:
<code language="asm">
push 0   ; начальное значение счётчика цикла
:1       ; метка начала цикла
push 1   ; кладём единицу, на которую увеличим счётчик цикла
add      ; инкремент счётчика
dup      ; копия для проверки условия выхода из цикла
dup      ; дубликат для подсчёта квадрата
dup      ; дубликат для подсчёта квадрата
dup      ; дубликат для вывода числа
out      ; выводим само число
mul      ; считаем квадрат числа
out      ; выводим квадрат числа
push 10  ; кладём граничное значение цикла
jb :1    ; прыжок если stack[-2] < stack[-1]</code>


== Дизайн команд ==

Команды из архитектуры, представленной выше, съедают все свои аргументы со стека. Подумайте, насколько это оправдано, и не хотите ли вы поменять их дизайн.

Имеется ввиду следующее. Пусть нужно распечатать вершину стека, после чего продолжить с ней работать. В нашей архитектуре для этого надо написать
<code language="asm">
dup
out</code>

Если бы команда `out` не съедала свой аргумент, то мы могли бы просто написать 
<code language="asm">
out</code>
Вершина стека при этом осталась бы нетронутой.



== Интерпретатор, ассемблер, дизассемблер ==

Реализуйте интерпретатор, ассемблер и дизассемблер для этого языка команд.

Для осуществления интерпретации и ассемблирования советуем делать два прохода по тексту программы. На первом проходе никакие действия в режиме интерпретации не исполняются, а для всех меток запоминается номер команды, на которую они указывают. На втором проходе для всех команд `jb` (или для ваших собственных команд условного перехода) по номеру метки проставляется номер команды, на которую надо делать прыжок.